/****************************************************************************
 * This file is part of Vibe.
 *
 * Copyright (c) 2010-2011 Pier Luigi Fiorini
 *
 * Author(s):
 *	Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
 *
 * Vibe is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Vibe is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Vibe.  If not, see <http://www.gnu.org/licenses/>.
 ***************************************************************************/

#ifndef VGLOBAL_H
#define VGLOBAL_H

#include <QtCore/qglobal.h>

/**
 * Vibe libraries version string.
 */
#define VIBE_VERSION_STR "@VIBE_VERSION_STR@"

/**
 * Vibe libraries version number.
 * VIBE_VERSION is (major << 16) + (minor << 8) + release.
 * If you want to check which version is in use you can use QT_VERSION_CHECK.
 * Example:
 * @code
 * #if (VIBE_VERSION >= QT_VERSION_CHECK(0, 9, 0))
 * ...
 * #endif
 * @endcode
 */
#define VIBE_VERSION (@VIBE_VERSION_MAJOR@ << 16) + (@VIBE_VERSION_MINOR@ << 8) + @VIBE_VERSION_RELEASE@

/**
 * Symbols import and export.
 */

#if defined(Q_OS_LINUX)
#  define VIBE_DECL_EXPORT     __attribute__((visibility("default")))
#  define VIBE_DECL_IMPORT     __attribute__((visibility("default")))
#  define VIBE_DECL_HIDDEN     __attribute__((visibility("hidden")))
#endif

#ifndef VIBE_DECL_EXPORT
#  if defined(Q_OS_WIN)
#    define VIBE_DECL_EXPORT __declspec(dllexport)
#  elif defined(QT_VISIBILITY_AVAILABLE)
#    define VIBE_DECL_EXPORT __attribute__((visibility("default")))
#    define VIBE_DECL_HIDDEN __attribute__((visibility("hidden")))
#  endif
#  ifndef VIBE_DECL_EXPORT
#    define VIBE_DECL_EXPORT
#  endif
#endif
#ifndef VIBE_DECL_IMPORT
#  if defined(Q_OS_WIN)
#    define VIBE_DECL_IMPORT __declspec(dllimport)
#  else
#    define VIBE_DECL_IMPORT
#  endif
#endif
#ifndef VIBE_DECL_HIDDEN
#  define VIBE_DECL_HIDDEN
#endif

#if defined(VIBE_BUILDING)
#  define VIBE_EXPORT VIBE_DECL_EXPORT
#else
#  define VIBE_EXPORT VIBE_DECL_IMPORT
#endif

/*
 * The following code is based on kde4libs/kdecore/kernel/kglobal.h
 *
 * Copyright (C) 1999 Sirtaj Singh Kanq <taj@kde.org>
 * Copyright (C) 2007 Matthias Kretz <kretz@kde.org>
 */

/// @cond InternalDocs

/**
 * @internal
 */
typedef void (*VibeCleanUpFunction)();

/**
 * @internal
 *
 * Helper class for VIBE_GLOBAL_STATIC to clean up the object on library unload or application
 * shutdown.
 */
class VCleanUpGlobalStatic
{
public:
    VibeCleanUpFunction func;

    inline ~VCleanUpGlobalStatic() {
        func();
    }
};

/**
 * @internal
 *
 * Make the struct of the VIBE_GLOBAL_STATIC anonymous.
 */
#define VIBE_GLOBAL_STATIC_STRUCT_NAME(NAME)

/// @endcond

/**
 * This macro makes it easy to use non-POD types as global statics.
 * The object is created on first use and creation is threadsafe.
 *
 * The object is destructed on library unload or application exit.
 * Be careful with calling other objects in the destructor of the class
 * as you have to be sure that they (or objects they depend on) are not already destructed.
 *
 * @param TYPE The type of the global static object. Do not add a *.
 * @param NAME The name of the function to get a pointer to the global static object.
 *
 * If you have code that might be called after the global object has been destroyed you can check
 * for that using the isDestroyed() function.
 *
 * If needed (If the destructor of the global object calls other functions that depend on other
 * global statics (e.g. KConfig::sync) your destructor has to be called before those global statics
 * are destroyed. A Qt post routine does that.) you can also install a post routine (qAddPostRoutine) to clean up the object
 * using the destroy() method. If you registered a post routine and the object is destroyed because
 * of a lib unload you have to call qRemovePostRoutine!
 *
 * Example:
 * @code
 * class A {
 * public:
 *     ~A();
 *     ...
 * };
 *
 * VIBE_GLOBAL_STATIC(A, globalA)
 * // The above creates a new globally static variable named 'globalA' which you
 * // can use as a pointer to an instance of A.
 *
 * void doSomething()
 * {
 *     //  The first time you access globalA a new instance of A will be created automatically.
 *     A *a = globalA;
 *     ...
 * }
 *
 * void doSomethingElse()
 * {
 *     if (globalA.isDestroyed()) {
 *         return;
 *     }
 *     A *a = globalA;
 *     ...
 * }
 *
 * void installPostRoutine()
 * {
 *     // A post routine can be used to delete the object when QCoreApplication destructs,
 *     // not adding such a post routine will delete the object normally at program unload
 *     qAddPostRoutine(globalA.destroy);
 * }
 *
 * A::~A()
 * {
 *     // When you install a post routine you have to remove the post routine from the destructor of
 *     // the class used as global static!
 *     qRemovePostRoutine(globalA.destroy);
 * }
 * @endcode
 *
 * A common case for the need of deletion on lib unload/app shutdown are Singleton classes. Here's
 * an example how to do it:
 * @code
 * class MySingletonPrivate;
 * class MySingleton
 * {
 * friend class MySingletonPrivate;
 * public:
 *     static MySingleton *self();
 *     QString someFunction();
 *
 * private:
 *     MySingleton();
 *     ~MySingleton();
 * };
 * @endcode
 * in the .cpp file:
 * @code
 * // This class will be instantiated and referenced as a singleton in this example
 * class MySingletonPrivate
 * {
 * public:
 *     QString foo;
 *     MySingleton instance;
 * };
 *
 * VIBE_GLOBAL_STATIC(MySingletonPrivate, mySingletonPrivate)
 *
 * MySingleton *MySingleton::self()
 * {
 *     // returns the singleton; automatically creates a new instance if that has not happened yet.
 *     return &mySingletonPrivate->instance;
 * }
 * QString MySingleton::someFunction()
 * {
 *     // Refencing the singleton directly is possible for your convenience
 *     return mySingletonPrivate->foo;
 * }
 * @endcode
 *
 * Instead of the above you can use also the following pattern (ignore the name of the namespace):
 * @code
 * namespace MySingleton
 * {
 *     QString someFunction();
 * }
 * @endcode
 * in the .cpp file:
 * @code
 * class MySingletonPrivate
 * {
 * public:
 *     QString foo;
 * };
 *
 * VIBE_GLOBAL_STATIC(MySingletonPrivate, mySingletonPrivate)
 *
 * QString MySingleton::someFunction()
 * {
 *     return mySingletonPrivate->foo;
 * }
 * @endcode
 *
 * Now code that wants to call someFunction() doesn't have to do
 * @code
 * MySingleton::self()->someFunction();
 * @endcode
 * anymore but instead:
 * @code
 * MySingleton::someFunction();
 * @endcode
 *
 * @ingroup Macros
 */
#define VIBE_GLOBAL_STATIC(TYPE, NAME) VIBE_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ())

/**
 * @overload
 * This is the same as VIBE_GLOBAL_STATIC, but can take arguments that are passed
 * to the object's constructor
 *
 * @param TYPE The type of the global static object. Do not add a *.
 * @param NAME The name of the function to get a pointer to the global static object.
 * @param ARGS the list of arguments, between brackets
 *
 * Example:
 * @code
 * class A
 * {
 * public:
 *     A(const char *s, int i);
 *     ...
 * };
 *
 * VIBE_GLOBAL_STATIC_WITH_ARGS(A, globalA, ("foo", 0))
 * // The above creates a new globally static variable named 'globalA' which you
 * // can use as a pointer to an instance of A.
 *
 * void doSomething()
 * {
 *     //  The first time you access globalA a new instance of A will be created automatically.
 *     A *a = globalA;
 *     ...
 * }
 * @endcode
 *
 * @ingroup Macros
 */
#define VIBE_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ARGS)                                      \
static QBasicAtomicPointer<TYPE> _q_static_##NAME = Q_BASIC_ATOMIC_INITIALIZER(0);          \
static bool _q_static_##NAME##_destroyed;                                                   \
static struct VIBE_GLOBAL_STATIC_STRUCT_NAME(NAME)                                          \
{                                                                                           \
    inline bool isDestroyed() const                                                         \
    {                                                                                       \
        return _q_static_##NAME##_destroyed;                                                \
    }                                                                                       \
    inline bool exists() const                                                              \
    {                                                                                       \
        return _q_static_##NAME != 0;                                                       \
    }                                                                                       \
    inline operator TYPE*()                                                                 \
    {                                                                                       \
        return operator->();                                                                \
    }                                                                                       \
    inline TYPE *operator->()                                                               \
    {                                                                                       \
        if (!_q_static_##NAME) {                                                            \
            if (isDestroyed()) {                                                            \
                qFatal("Fatal Error: Accessed global static '%s *%s()' after destruction. " \
                       "Defined at %s:%d", #TYPE, #NAME, __FILE__, __LINE__);               \
            }                                                                               \
            TYPE *x = new TYPE ARGS;                                                        \
            if (!_q_static_##NAME.testAndSetOrdered(0, x)                                   \
                && _q_static_##NAME != x ) {                                                \
                delete x;                                                                   \
            } else                                                                          \
                static VCleanUpGlobalStatic cleanUpObject = { destroy };                    \
        }                                                                                   \
        return _q_static_##NAME;                                                            \
    }                                                                                       \
    inline TYPE &operator*()                                                                \
    {                                                                                       \
        return *operator->();                                                               \
    }                                                                                       \
    static void destroy()                                                                   \
    {                                                                                       \
        _q_static_##NAME##_destroyed = true;                                                \
        TYPE *x = _q_static_##NAME;                                                         \
        _q_static_##NAME = 0;                                                               \
        delete x;                                                                           \
    }                                                                                       \
} NAME;

#endif // VGLOBAL_H
